xss


反射型

黑客把恶意脚本代码参数的url地址发送给用户
用户点击此链接
服务器端获取请求参数并且直接使用，服务器反射回结果页面

反射型xss攻击是一次性的 必须要通过用户点击链接才能发起
 服务器没有对恶意的用户输入进行安全处理就直接反射响应内容，容易恶意代码在浏览器中执行的一种xss漏洞


 输入    xxxx?<script>alert(1)</script> 传给服务器服务器返回回来就会执行


 存储型

 经常评论网站 直接提交，存储到服务器，直接返回

 1. 黑客将恶意脚本代码上传或存储到漏洞服务器
 2. 服务器把恶意脚本保存到服务器
 3. 当正常客户访问服务器时，服务器会读取恶意数据并直接使用
 4. 服务器会返回含有恶意脚本的页面
   

DOM-Based

不需要服务器支持 由于dom结果修改导致，基于浏览器dom解析的攻击

1. 用户打开带有恶意的链接
2. 浏览器在dom解析的时候直接使用恶意数据
3. 用户中招
4. 常见的触发场景是在修改innerHTML outerHTML documenr.write  的时候


payload


实现xss攻击的恶意脚本被成为 xss payload

窃取用户的cookie document.cookie

识别用户浏览器 navigator.userAgent

伪造请求get post请求

xss钓鱼 通过css向网页上注入钓鱼链接 让用户访问假冒的网站


如何防御：

给cookie 加上httpOnly属性，脚本无法读取cookie，自己也不能用，非根本解决xss

url编码
encodeURL(url)  常见用来编码url的，转为utf8格式，对于保留字符以及非转义字符不会进行转义

encodeURLComponent('&?')  用来编码url参数的，会跳过转义字符 但是会转义url的保留字符

所有完整编码一个url字符串需要encodeURL和encodeURLComponent联合使用

html编码

在html中，某些字符是预留的，比如不能使用小于号或者大于号，这是因为浏览器会误认为是标签，如果希望正确的显示预留字符 必须在html源代码中使用字符实体
分为：

html十六进制编码 &#xH
十进制编码 &#D
实体编码 < 等

前端过滤
后端过滤（阻止用node模拟的请求）
输出过滤（展示的时候再过滤下）
输入检查：

1. 永远不要相信用户的输入
2. 用户格式判断  白名单
3. 过滤危险字符 去除
4. 事件属性中  加入防线


CSRF  跨站请求伪造

1. 用户a登陆银行网站 登陆成功后去设置cookie
2. 黑客诱导用户a登陆到黑客的站点，然后返回一个页面
3. 用户访问这个页面时，这个页面会伪造一个转账请求到银行网站